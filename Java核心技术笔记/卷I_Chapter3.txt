# 1.基本内容

- 一个简单的Java程序
  - 程序入口
  - 术语
  - 提醒

- 3种注释
  - // /\*\*/ /***/

- 8种基本数据类型
- 变量常量
- 运算符
- 字符串
- 输入输出
- 控制流
- 大数
- 数组



# 2.	简单的Java程序

- public static void main(String[] args) main当做咒语记住
- Main函数是Java程序的唯一入口
  - 在idea里，可以用 main + [Tab] 打出

- 然后是一些Tips：

| Item                   | 详细解释                                                     |
| ---------------------- | ------------------------------------------------------------ |
| 大小写敏感             | Java区分大小写                                               |
| 访问修饰符             | public、protected、private                                   |
| 类 class               | 一类对象属性和行为的封装                                     |
| 类名                   | 类名以字母开头，后面可以跟字母和数字的任意组合；长度没有限制，但是不能使用**Java保留字**；这里的字母是广义字母，包括[a-zA-Z_$] |
| 驼峰命名法、骆驼命名法 | 类名首字母要大写；方法和变量首字母可以不大写。               |
| 程序块                 | { } 花括号括起来                                             |
| java程序运行流程       | javac filename.java 将java源代码编译成bytecode，然后 java  filename 让jvm执行字节码；javac是一个编译器。 |
| 文件名                 | 源文件名和公共类名一样                                       |
| 语句                   | 声明/调用后接 ';' 才是一条语句 ， 语句以分号 ; 结尾          |



# 3.	3种注释

- // 行
- /*    */ 多行，不可嵌套
- /**    */ 文档或格式化的注释，不可嵌套



# 4.数据类型

java：静态强类型，编译器在编译期会做严格的数据类型检查。



## 8种基本类型：

6整+2浮点，严格说是4种整形，2种浮点，1个Boolean，1个字符型。

| 名称    | 类型     | 字节 |
| ------- | -------- | ---- |
| int     | 标准整型 | 4    |
| short   | 短整型   | 2    |
| byte    | 字节     | 1    |
| long    | 长整型   | 8    |
| float   | 短浮点   | 4    |
| double  | 长浮点   | 8    |
| char    | 字符型   | 2    |
| boolean | 布尔值   | 1    |

### 注意：

- Int、long的字节数是确定的。
- Char是2个字节，对应Unicode字符！



## 4.1	整型

| 名称  | 字节数 | 范围和精度                                   |
| ----- | ------ | -------------------------------------------- |
| int   | 4      | -2 147 483 648 ~ 2 147 483 647（-21亿~21亿） |
| short | 2      | -32768 ~ 32767                               |
| byte  | 1      | -128 ~ 127                                   |
| long  | 8      | 9开头，19位数                                |

- byte和short在特定应用场景下很有用，比如底层的文件处理或者存储空间时，使用byte或short类型的大数组
  - 比如：读取某个硬盘数据时，使用` byte[] bytes=new byte[10000]……`
- Int型规定是4个字节，这与C/C++要求 int 满足 `short<= int <= long `有区别！
  - C/C++在有的系统上，int16位，有的系统上int 32位。好处是性能灵活适应，缺点是跨平台性严重受损。32位int程序移植到16位int环境下会发生整数溢出。
  - 这支持了Java的跨平台、可移植性。
- 长整数型需要加后缀 “L”或“l”
- 前缀 0x或 0X 代表是16进制数； 前缀 0b 或者 0B代表是2进制数； 前缀 0 代表是8进制数；
  - 八进制常数表示容易混淆，最好不要使用
- 从Java7开始，在数字字面量里可以加入"_"，比如 一百万： 1_000_000； 编译器在接收词法单元流以后，可以去除这些/过滤掉这些下划线。
- Java没有任何无符号类型的`int、long、short、byte`
  - 要使用无符号类型的数，可以考虑`Byte\Short\Integer\Long`类的处理无符号处罚和求余数的方法。



## 4.2	浮点数

| 名称   | 字节数 | 范围                              | 精度  |
| ------ | ------ | --------------------------------- | ----- |
| float  | 4      | +- 3.402 823 47E+38F              | 6~7位 |
| double | 8      | +- 1.797 693 134 862 315 70E +308 | 15位  |

- 很少情况下使用 `float`
- 使用`float`时注意数值后需要紧跟后缀“F”或者“f” 
- 没有后缀的浮点数默认是`double`，当然也可以在后面跟后缀“D”或者“d”，也是`double`
- 可以使用十六进制来表示浮点数
  - 比如 0.125 = 2^-3 可以写作  0x 1.0 p **-3**
  - 特点是 0x 或 0X 开头
  - 尾数那里可以出现 a\b\c\d\e\f
  - 尾数和指数的界限符是'p'
  - 指数的基底是 2，指数本身用 十进制表示
- 所有浮点数都遵循IEEE 754规范，下面是表示溢出和出错情况下的特殊的浮点数字：
  - 正无穷大
  - 负无穷大
  - NaN
  - 常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY、Double.NaN分别表示这3个特殊的值
  - 所有“NaN”的值都是不同的。可以使用 Double.isNaN方法来判断：
    - if(Double.isNaN(x)) ...
- 浮点数值因为固有的误差，不适用于金融计算。



## 4.3	char

- char类型的字面量需要用单引号' '括起来。
- char类型的值可以表示为十六进制，需要用转义序列 \u + 4位十六进制数来表示
  - 比如： \u0000  \u03C0 \u2122
- 警告：Unicode转义序列会在代码解析前就得到处理。
  - 比如，“\u0022+\u0022”会在解析前被处理转换，\u0022会被转换为“，最终得到”“+”“，结果为一个空串
- 警告：更要注意注释中的"\u"
  - //\u000A is a new line 这个注释会报错
  - 因为\u000A是换行符，他让后续的 is a new line脱离了行注释的范围，到下一行去了。

P33&P34：

> Unicode标准里，码点采用16进制书写，并加上前缀U+。比如U+0041就是拉丁字母‘A’。Unicode的码点可以分为17个代码平面。第一个代码平面是基本多语言平面，包括从U+0000到U+FFFF的“经典”Unicode代码；其余的16个平面的码点是从U+10000到U+10FFFF，包括了辅助字符。
>
> UTF-16编码采用不同长度的编码表示所有Unicode码点。在第一个代码平面，使用16位表示；在其他平面，使用2个代码单元表示。

在Java中，char类型描述了UTF-16编码中的一个`代码单元`

> 我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。



## 4.4	布尔值

- false & true
- 整数和布尔值之间不能互相转换！
- 使得以下情况会出现报错提示：
  - if(x=0) ……
  - 在C/C++情况下，这会默认是0（false），不会提醒程序员
  - Java下，这会直接由编译器报错；x=0不能转换为布尔表达式。



# 5.	变量与常量

- 变量声明
- 变量初始化
- 常量
- 枚举类型

## 5.1	变量声明

一句变量声明语句：`类型名 变量名 ;`

- 变量名以字母开头，数字和字母自由组合，变量名的长度没有限制
  - 这里的字母包括 a-z A-Z 下划线_  $ 和其他任意Unicode字符
  - 不能用`单个下划线_`作为变量名
- 大小写敏感
- 变量名要**避免与Java保留字冲突**
- 可以一行声明多个变量，但是这种写法不推荐。

> 一些程序员需要喜欢将变量名命名为类型名
>
> Box box;
>
> StringBuilder stringBuilder;
>
> 或者在前面加一个'a'
>
> BufferedReader aBufferedReader;



## 5.2	变量初始化

- 千万不要使用未经初始化的变量
- Java不区分变量的声明和定义（不像C/C++那样）
- 尽量将初始化放在靠近变量声明的地方
- 从Java10开始，对于局部变量，可以使用 `var`从变量的初始值来推断 变量的类型，比较类似C++的`auto`



## 5.3	常量

- 可以利用关键字`final`来指示常量。
- 习惯上，常量名全部大写。
- 如果希望一个类的不同方法反复使用同一个常量，可以使用`static final`定义一个类常量。
- const 是Java保留的关键字，但目前并没有使用。必须使用 `final`定义常量。



## 5.4	枚举类型

变量的取值范围集是**确定且个数有限的**。

写法：

- `enum Size {Small,Big,Middle}; `,`Size s=Size.Big;`
- 注意`Size`型变量的值只可以取 `Small,Big,Middle和null`



# 6.运算符

## 6.1	算术运算符

- +、-、*、/、%
- 注意 / 默认是整数除法，只有当除数或被除数中至少有一个是浮点数时，才是浮点数除法。
- 整数被0除会产生一个异常，而浮点数被0除会得到正负无穷大、或NaN的结果。

书这里花了很大篇幅讲算术运算符与Java可移植性的问题，在书P37。这里摘录一部分：

> 无论在哪个虚拟机上运行，同一个运算应该得到相同的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位存储一个数值，而有些处理器则使用80位的浮点寄存器。这些中间结果的寄存器增加了中间过程的计算精度。
>
> 比如：
>
> `double w=x*y/z;`
>
> 很多Intel处理器计算 x*y，会将结果存储在80位的寄存器中，再除以z，将结果截断为64位。这样可以产生更精确的计算结果，并且防止指数溢出。
>
> 但是这个结果与始终用64位寄存器进行计算的处理器得出的结果不一致。
>
> 因此，Java虚拟机最初规定所有中间计算都必须要**截断**。
>
> 但遭到了社区的强烈抵制。
>
> 最终Java官方做了妥协，不再强制要求中间结果进行截断。
>
> 但也提供了 `strictfp` 方法修饰符来要求方法里的所有中间结果必须进行截断。
>
> 但客观来说，`strictfp`的使用非常有限。



## 6.2	数学函数与常量

在Math类中，包含了各种各样的数学函数和常量。

比如：

- 计算平方根的 Math.sqrt(double x)
- 计算幂的 Math.pow(double base,double e)
- 计算绝对值的Math.abs()
- 计算余数的 Math.floorMod(被除数,除数)
  - 注意floorMod是为了解决Java设计 ‘%’的一个问题：
  -  -4 % 3 = -1 ，这与我们的数学常识和数学习惯相背离！
  - 我们希望的是余数 r 永远满足 : 0 <= r < 除数
  - 所以 Math.floorMod(-4,3) 返回的就是 2
  - 但注意，floorMod在除数为负时，会返回负数结果。（实现的咋这么拉呀……）



下面是Math提供的更多数学相关实体：

| 名称       | 类型               |
| ---------- | ------------------ |
| Math.sin   | 三角函数           |
| Math.cos   | 三角函数           |
| Math.tan   | 三角函数           |
| Math.atan  | 反三角函数         |
| Math.atan2 | 反三角函数         |
| Math.pow   | 指数函数           |
| Math.exp   | 自然指数           |
| Math.log   | 自然对数           |
| Math.log10 | 以10为底的对数函数 |
| Math.PI    | 常量，π            |
| Math.E     | 常量，自然指数     |
| Math.abs   | 绝对值函数         |
| Math.round | 四舍五入           |

**提示：**

- 通过静态引入，可以不用写“Math."

> import static java.lang.Math.*;
>
> System.out.print(sqrt(PI))；

- 精度和性能

> Math库里的方法兼顾了性能和准确性。如果要得到一个完全可预测的、完全精准的运行结果的话，应该使用`StrictMath`类。

- 运算安全性

> 如果一个计算溢出，数学运算符返回错误的结果而不做任何提醒；但如果用Math类的方法，则会有更好的运算安全性。
>
> 比如计算 int a= 10亿 * 3; 用运算符会溢出错误；
>
> 而用Math.multiplyExact(10亿,3);会生成一个异常。
>
> 类似的还有addExact\subtractExact、incrementExact、decrementExact、negateExact等等。

## 6.3	数值类型的转换

最强的2个类型：long 和 double。

![类型转换图](img/类型转换图.png)

​	运算符连接多个值时，比如一个整数和一个浮点数，先要将2个操作数转换为同一种类型，然后再进行计算。

​	类型转换规则如下：

- 第一，如果2个操作数中，有一个是Double另一个就会转换为Double。
- 第二，如果其中一个是float，另一个就会转换为float。
- 第三，如果其中一个是long，另一个会转换为long型。
- 否则，2个操作数都被转换为int类型。



## 6.4	强制类型转换

int转Double不损失信息，但Java也允许将Double类型转换成int，当然这个过程中变量可能损失信息。

Java中这种可能损失信息的转换，需要通过`强制类型转换`来完成。

`强制类型转换`的语法格式是在`圆括号`中给出想要转换的目标类型，在括号后面`紧跟需要转换的变量名`。

> 如:
>
> double p=3.14;
>
> int x=(int)p;
>
> 这里直接截断浮点数的小数部分。

如果对浮点数要进行四舍五入的运算，可以使用Math.round方法，但Math.round返回的是一个Long值。

提示：

> 不要在boolean类型与其他任何类型之间进行强制类型转换，这样可以防止发生一些常见的错误。如果需要将布尔类型转换为数值类型可以使用条件表达式。比如 int b= bool? 1 : 0;

提示：

> 如果将1个数，从1种类型转换为另1种类型，但又超出了目标类型的范围，结果会得到一个完全不同的值。
>
> 比如(byte)300 的值为44。

## 6.5	运算符

### 1.	赋值和结合赋值

- 赋值运算符 结合性为从右到左，优先级为最低，是二元操作符。
- 结合赋值的 结合性也是从右到左，优先级也最低。
- 注意赋值和结合赋值过程中可能会出现强制类型转换。

x=x+4; <=> x+=4;

### 2.	自增自减

自增和自减运算符有前缀和后缀2种形式。

前缀形式是先自增/自减，再运算。

后缀形式是先参与其他运算，最后再自增/减。

a++、++a、--a、a--

提示：

> 应该尽量少使用自增和自减运算符，尤其不要在复杂的表达式里使用，它会大大降低可读性。

### 3.	关系和Boolean运算符

`!= == > < >= <= && || ?:`

注意：

- 逻辑与和逻辑或具有短路求值机制。

### 4.	位运算符

`>> >>> << & | ! ~`

> \>>算数右移，按照符号来补充左边缺失的数
>
> \>\>\> 逻辑右移，在左边补0
>
> << 算术左移，在右边补0
>
> & 对每一位做与操作
>
> |  对每一位做或操作
>
> ！对每一位做非操作
>
> ^ 对每一位做异或操作
>
> ~ 对每一位做取反操作



## 6.6	括号和运算级别

 Java的运算符优先级顺序是：

- 下标和调用运算符
- 单目运算符（包括取非、取反、自增、自减、正号、负号）、new、强制类型转换
- 算术运算符
- 移位运算符
- 关系运算符、instance of
- 位运算符
- 逻辑运算符
- 赋值运算符

<img src="img/运算符优先级.png" alt="运算符优先级" style="zoom: 67%;" />



# 7.字符串

- Java字符串是Unicode字符序列。
- Java没有内置的字符串类型，它是在标准Java类库中预定义了一个String类。 
- 每个用双引号括起来的字符串都是String类的实例。

## 7.1	子串 substring

- substring(int begin,int end)方法
- 左闭右开 表示取string的下标区间是[begin,end)
- 长度为 end - begin

## 7.2	拼接 +

- Java也提供了 ‘+’的语法糖，允许使用 + 来连接多个字符串
- 任何一个Java对象都是Object类的子类，Object类具有toSring方法，所以任何一个Java对象都可以字符串化
- 将一个字符串与非字符串对象拼接时，非字符串对象会转换成字符串
- 如果需要用1个统一的界限符来将多个字符串连接起来，可以使用String类的静态join方法

如：

> String all=String.join("/","S","M","L"); // all  为 S / M / L

Java11还提供了repeat方法：

> String str="Java".repeat(2)

## 7.3	不可变字符串





## 7.4	检测串相等

## 7.5	空串与NULL

## 7.6	码点

## 7.7	重要的API

## 7.8	文档

## 7.9	StringBuilder





# 8.输入与输出



# 9.大数



# 10.数组



rrrrefdrre
